"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScreenClass = void 0;
const process_1 = require("process");
const file_type_enum_1 = require("./file-type.enum");
const generate_output_path_function_1 = require("./generate-output-path.function");
const match_request_class_1 = require("./match-request.class");
const region_class_1 = require("./region.class");
const timeout_function_1 = require("./util/timeout.function");
const image_class_1 = require("./image.class");
const point_class_1 = require("./point.class");
function validateSearchRegion(search, screen) {
    if (search.left < 0 || search.top < 0 || search.width < 0 || search.height < 0) {
        throw new Error(`Negative values in search region ${search}`);
    }
    if (isNaN(search.left) || isNaN(search.top) || isNaN(search.width) || isNaN(search.height)) {
        throw new Error(`NaN values in search region ${search}`);
    }
    if (search.width < 2 || search.height < 2) {
        throw new Error(`Search region ${search} is not large enough. Must be at least two pixels in both width and height.`);
    }
    if (search.left + search.width > screen.width || search.top + search.height > screen.height) {
        throw new Error(`Search region ${search} extends beyond screen boundaries (${screen.width}x${screen.height})`);
    }
}
/**
 * {@link ScreenClass} class provides methods to access screen content of a systems main display
 */
class ScreenClass {
    /**
     * {@link ScreenClass} class constructor
     * @param providerRegistry A {@link ProviderRegistry} used to access underlying implementations
     * @param findHooks A {@link Map} of {@link FindHookCallback} methods assigned to a template image
     */
    constructor(providerRegistry, findHooks = new Map()) {
        this.providerRegistry = providerRegistry;
        this.findHooks = findHooks;
        /**
         * Config object for {@link ScreenClass} class
         */
        this.config = {
            /**
             * Configures the required matching percentage for template images to be declared as a match
             */
            confidence: 0.99,
            /**
             * Configure whether to auto highlight all search results or not
             */
            autoHighlight: false,
            /**
             * Configure highlighting duration
             */
            highlightDurationMs: 500,
            /**
             * Configure opacity of highlight window
             */
            highlightOpacity: 0.25,
            /**
             * Configures the path from which template images are loaded from
             */
            resourceDirectory: (0, process_1.cwd)(),
        };
    }
    /**
     * {@link width} returns the main screen width
     * This refers to the hardware resolution.
     * Screens with higher pixel density (e.g. retina displays in MacBooks) might have a higher width in in actual pixels
     */
    width() {
        return this.providerRegistry.getScreen().screenWidth();
    }
    /**
     * {@link height} returns the main screen height
     * This refers to the hardware resolution.
     * Screens with higher pixel density (e.g. retina displays in MacBooks) might have a higher height in in actual pixels
     */
    height() {
        return this.providerRegistry.getScreen().screenHeight();
    }
    /**
     * {@link find} will search for a single occurrence of a template image on a systems main screen
     * @param template Template {@link Image} instance
     * @param params {@link LocationParameters} which are used to fine tune search region and / or match confidence
     */
    async find(template, params) {
        const { minMatch, screenSize, searchRegion, screenImage, searchMultipleScales } = await this.getFindParameters(params);
        const needle = await ScreenClass.getNeedle(template);
        const matchRequest = new match_request_class_1.MatchRequest(screenImage, needle, minMatch, searchMultipleScales);
        return new Promise(async (resolve, reject) => {
            try {
                validateSearchRegion(searchRegion, screenSize);
                const matchResult = await this.providerRegistry.getImageFinder().findMatch(matchRequest);
                const possibleHooks = this.findHooks.get(needle) || [];
                for (const hook of possibleHooks) {
                    await hook(matchResult);
                }
                const resultRegion = new region_class_1.Region(searchRegion.left + matchResult.location.left, searchRegion.top + matchResult.location.top, matchResult.location.width, matchResult.location.height);
                if (this.config.autoHighlight) {
                    resolve(this.highlight(resultRegion));
                }
                else {
                    resolve(resultRegion);
                }
            }
            catch (e) {
                reject(`Searching for ${needle.id} failed. Reason: '${e}'`);
            }
        });
    }
    /**
     * {@link findAll} will search for every occurrences of a template image on a systems main screen
     * @param template Template {@link Image} instance
     * @param params {@link LocationParameters} which are used to fine tune search region and / or match confidence
     */
    async findAll(template, params) {
        const { minMatch, screenSize, searchRegion, screenImage, searchMultipleScales } = await this.getFindParameters(params);
        const needle = await ScreenClass.getNeedle(template);
        const matchRequest = new match_request_class_1.MatchRequest(screenImage, needle, minMatch, searchMultipleScales);
        return new Promise(async (resolve, reject) => {
            try {
                validateSearchRegion(searchRegion, screenSize);
                const matchResults = await this.providerRegistry.getImageFinder().findMatches(matchRequest);
                const possibleHooks = this.findHooks.get(needle) || [];
                for (const hook of possibleHooks) {
                    for (const matchResult of matchResults) {
                        await hook(matchResult);
                    }
                }
                const resultRegions = matchResults.map(matchResult => {
                    return new region_class_1.Region(searchRegion.left + matchResult.location.left, searchRegion.top + matchResult.location.top, matchResult.location.width, matchResult.location.height);
                });
                if (this.config.autoHighlight) {
                    resultRegions.forEach(region => this.highlight(region));
                    resolve(resultRegions);
                }
                else {
                    resolve(resultRegions);
                }
            }
            catch (e) {
                reject(`Searching for ${needle.id} failed. Reason: '${e}'`);
            }
        });
    }
    /**
     * {@link highlight} highlights a screen {@link Region} for a certain duration by overlaying it with an opaque highlight window
     * @param regionToHighlight The {@link Region} to highlight
     */
    async highlight(regionToHighlight) {
        const highlightRegion = await regionToHighlight;
        await this.providerRegistry.getScreen().highlightScreenRegion(highlightRegion, this.config.highlightDurationMs, this.config.highlightOpacity);
        return highlightRegion;
    }
    /**
     * {@link waitFor} searches for a template image for a specified duration
     * @param templateImage Filename of the template image, relative to {@link ScreenClass.config.resourceDirectory}, or an {@link Image}
     * @param timeoutMs Timeout in milliseconds after which {@link waitFor} fails
     * @param updateInterval Update interval in milliseconds to retry search
     * @param params {@link LocationParameters} which are used to fine tune search region and / or match confidence
     */
    async waitFor(templateImage, timeoutMs = 5000, updateInterval = 500, params) {
        const needle = await templateImage;
        if (!(0, image_class_1.isImage)(needle)) {
            throw Error(`waitFor requires an Image, but received ${JSON.stringify(templateImage)}`);
        }
        return (0, timeout_function_1.timeout)(updateInterval, timeoutMs, () => this.find(needle, params), { signal: params === null || params === void 0 ? void 0 : params.abort });
    }
    /**
     * {@link on} registers a callback which is triggered once a certain template image is found
     * @param templateImage Template image to trigger the callback on
     * @param callback The {@link FindHookCallback} function to trigger
     */
    on(templateImage, callback) {
        if (!(0, image_class_1.isImage)(templateImage)) {
            throw Error(`on requires an Image, but received ${JSON.stringify(templateImage)}`);
        }
        const existingHooks = this.findHooks.get(templateImage) || [];
        this.findHooks.set(templateImage, [...existingHooks, callback]);
    }
    /**
     * {@link capture} captures a screenshot of a systems main display
     * @param fileName Basename for the generated screenshot
     * @param fileFormat The {@link FileType} for the generated screenshot
     * @param filePath The output path for the generated screenshot (Default: {@link cwd})
     * @param fileNamePrefix Filename prefix for the generated screenshot (Default: empty)
     * @param fileNamePostfix Filename postfix for the generated screenshot (Default: empty)
     */
    async capture(fileName, fileFormat = file_type_enum_1.FileType.PNG, filePath = (0, process_1.cwd)(), fileNamePrefix = "", fileNamePostfix = "") {
        const currentScreen = await this.providerRegistry.getScreen().grabScreen();
        if (!(0, image_class_1.isImage)(currentScreen)) {
            throw Error(`capture requires an Image, but received ${JSON.stringify(currentScreen)}`);
        }
        return this.saveImage(currentScreen, fileName, fileFormat, filePath, fileNamePrefix, fileNamePostfix);
    }
    /**
     * {@link grab} grabs screen content of a systems main display
     */
    async grab() {
        return this.providerRegistry.getScreen().grabScreen();
    }
    /**
     * {@link captureRegion} captures a screenshot of a region on the systems main display
     * @param fileName Basename for the generated screenshot
     * @param regionToCapture The region of the screen to capture in the screenshot
     * @param fileFormat The {@link FileType} for the generated screenshot
     * @param filePath The output path for the generated screenshot (Default: {@link cwd})
     * @param fileNamePrefix Filename prefix for the generated screenshot (Default: empty)
     * @param fileNamePostfix Filename postfix for the generated screenshot (Default: empty)
     */
    async captureRegion(fileName, regionToCapture, fileFormat = file_type_enum_1.FileType.PNG, filePath = (0, process_1.cwd)(), fileNamePrefix = "", fileNamePostfix = "") {
        const targetRegion = await regionToCapture;
        if (!(0, region_class_1.isRegion)(targetRegion)) {
            throw Error(`captureRegion requires an Region, but received ${JSON.stringify(targetRegion)}`);
        }
        const regionImage = await this.providerRegistry.getScreen().grabScreenRegion(targetRegion);
        if (!(0, image_class_1.isImage)(regionImage)) {
            throw Error(`captureRegion requires an Image, but received ${JSON.stringify(regionImage)}`);
        }
        return this.saveImage(regionImage, fileName, fileFormat, filePath, fileNamePrefix, fileNamePostfix);
    }
    /**
     * {@link grabRegion} grabs screen content of a region on the systems main display
     * @param regionToGrab The screen region to grab
     */
    async grabRegion(regionToGrab) {
        return this.providerRegistry.getScreen().grabScreenRegion(await regionToGrab);
    }
    /**
     * {@link colorAt} returns RGBA color values for a certain pixel at {@link Point} p
     * @param point Location to query color information from
     */
    async colorAt(point) {
        const screenContent = await this.providerRegistry.getScreen().grabScreen();
        const inputPoint = await point;
        if (!(0, point_class_1.isPoint)(inputPoint)) {
            throw Error(`colorAt requires a Point, but received ${JSON.stringify(inputPoint)}`);
        }
        const scaledPoint = new point_class_1.Point(inputPoint.x * screenContent.pixelDensity.scaleX, inputPoint.y * screenContent.pixelDensity.scaleY);
        return this.providerRegistry.getImageProcessor().colorAt(screenContent, scaledPoint);
    }
    async saveImage(image, fileName, fileFormat, filePath, fileNamePrefix, fileNamePostfix) {
        const outputPath = (0, generate_output_path_function_1.generateOutputPath)(fileName, {
            path: filePath,
            postfix: fileNamePostfix,
            prefix: fileNamePrefix,
            type: fileFormat,
        });
        await this.providerRegistry.getImageWriter().store({ image, path: outputPath });
        return outputPath;
    }
    async getFindParameters(params) {
        var _a, _b, _c;
        const minMatch = (_a = params === null || params === void 0 ? void 0 : params.confidence) !== null && _a !== void 0 ? _a : this.config.confidence;
        const screenSize = await this.providerRegistry.getScreen().screenSize();
        const searchRegion = (_b = params === null || params === void 0 ? void 0 : params.searchRegion) !== null && _b !== void 0 ? _b : screenSize;
        const screenImage = await this.providerRegistry.getScreen().grabScreenRegion(searchRegion);
        const searchMultipleScales = (_c = params === null || params === void 0 ? void 0 : params.searchMultipleScales) !== null && _c !== void 0 ? _c : true;
        return ({
            minMatch,
            screenSize,
            searchRegion,
            screenImage,
            searchMultipleScales
        });
    }
    static async getNeedle(template) {
        const needle = await template;
        if (!(0, image_class_1.isImage)(needle)) {
            throw Error(`find requires an Image, but received ${JSON.stringify(needle)}`);
        }
        return needle;
    }
}
exports.ScreenClass = ScreenClass;
//# sourceMappingURL=screen.class.js.map